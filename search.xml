<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快手万亿级别Kafka集群应用实践与技术演进之路</title>
      <link href="/2019/06/17/kuai-shou-wan-yi-ji-bie-kafka-ji-qun-ying-yong-shi-jian-yu-ji-zhu-yan-jin-zhi-lu/"/>
      <url>/2019/06/17/kuai-shou-wan-yi-ji-bie-kafka-ji-qun-ying-yong-shi-jian-yu-ji-zhu-yan-jin-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p>Kafka集群被大量用来对流量高峰期限流、系统解耦合、削弱峰值等业务场景。Kafka提供了高性能的消息写入、持久化、读取的优化。每一种技术都不能解决所有的问题。</p><p>本文整理自快手高级架构师、大数据架构团队负责人赵健博在 QCon 全球软件开发大会（北京）2019 上的演讲，他介绍了 Kafka 系统在快手的应用实践、遇到的问题以及相应的技术的演进过程。</p><h1 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h1><p>日处理消息级别：万亿<br>峰值：1亿/s</p><h1 id="集群类别"><a href="#集群类别" class="headerlink" title="集群类别"></a>集群类别</h1><h2 id="kafka作为消息中间件"><a href="#kafka作为消息中间件" class="headerlink" title="kafka作为消息中间件"></a>kafka作为消息中间件</h2><pre><code>不同业务之间提供消息通知服务</code></pre><h2 id="LOG集群"><a href="#LOG集群" class="headerlink" title="LOG集群"></a>LOG集群</h2><pre><code>业务程序将Log打给kafka</code></pre><h2 id="离线集群"><a href="#离线集群" class="headerlink" title="离线集群"></a>离线集群</h2><pre><code>- 数据实时dump到hdfs- 为实时计算提供数据源- 为实时训练提供数据源</code></pre><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><h2 id="对borker的平滑扩容"><a href="#对borker的平滑扩容" class="headerlink" title="对borker的平滑扩容"></a>对borker的平滑扩容</h2><p>问题：</p><pre><code>系统需要新增一个borker时，如何平滑的将现有的topic平滑的迁移到新的broker上，从而实现topic的leader和follower的均匀分布？</code></pre><p>解决：</p><pre><code>1、在新的broker上创建副本用于迁移源topic(或其中一个副本)，2、读取的时候从最新的offset开始读     - 从最新的offset开始读，可避免大量I/O     - 有些已经消费过的数据后续不会用到，没有必要迁移3、保持一段时间，当所有的consumer都消费到开始读取的offset，即可删除源数据，迁移完成。</code></pre><h2 id="Mirror的集群化"><a href="#Mirror的集群化" class="headerlink" title="Mirror的集群化"></a>Mirror的集群化</h2><blockquote><p>kafka Mirror是kafka为集群的数据迁移提供的一个解决方案</p></blockquote><p>Kafka Mirror 存在的问题：</p><pre><code>1、静态管理，维护成本高、易出错    - topic 数量    - Mirror机器列表2、变更操作导致整体断流    - 增减 topic    - 机器扩容或缩容</code></pre><p>解决：</p><pre><code>基于 UReplicator，开发了 KReplcator 服务，并替换掉了现有的 MirrorMaker 服务。UReplicator 是 Uber 开源的 Kafka 数据 Mirror 同步服务。KReplcator 集群包含三个模块：    - Controller: 动态管理 topic、worker 的增减    - worker：数据的传输    - zookeeper：协调Controller与worker</code></pre><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>问题1：</p><pre><code>同一个业务线的topic分布在不同的broker上，不同业务线的topic分布在broker上，如果consumer出现问题，导致消费产生lag，lag积累会造成磁盘繁忙，影响其他业务线。</code></pre><p>解决：</p><pre><code>物理隔离，把不同的topic放到不同的broker，尽量减少业务线的交叉- 创建topic- 迁移topic- 宕机恢复流程</code></pre><p>问题2：</p><pre><code>kafka PRC 队列缺少隔离，某个topic慢，会导致所有请求hang up</code></pre><p>解决：</p><pre><code>分拆多个PRC队列，队列隔离</code></pre><h2 id="cache改造"><a href="#cache改造" class="headerlink" title="cache改造"></a>cache改造</h2><p>Kafka 之所以有如此高的性能，主要依赖于 page cache，producer 的写操作，broker 会将数据写入到 page cache 中，随后 consumer 发起读操作，如果短时间内 page cache 仍然有效，则 broker 直接从内存返回数据，这样，整体性能吞吐非常高。</p><p>问题：</p><pre><code>1、comsumer的lag读会对 page cache 产生污染2、follower 会造成 page cache 污染，follower写入的数据是一次性的，后续不会在被读取，所以缓存没有必要</code></pre><p>解决：同时写两个对象</p><pre><code>- block cache: block cache 中的数据全都是 producer 产生的- flush queue: flush queue 中的数据会由其他线程异步地写入到磁盘中对于 consumer 而言，在 broker 接到消费请求后，首先会从 block cache 中检索数据，如果命中，则直接返回。否则，则从磁盘读取数据。这样的读取模式保障了 consumer 的 cache miss 读并不会填充 block cache，从而避免了产生污染，即使有大 lag 的 consumer 读磁盘，也仍然保证 block cache 的稳定。</code></pre><h2 id="智能限速"><a href="#智能限速" class="headerlink" title="智能限速"></a>智能限速</h2><p>问题： </p><pre><code>consumer lag 导致producer写入受阻？</code></pre><p>解决：</p><pre><code>- 思路：当磁盘繁忙，针对lag的consumer进行限速控制- 添加限速模块，包含lag域值检测、限速策略、信息采集，延迟队列等</code></pre><p><a href="http://www.6aiq.com/article/1558077716919" target="_blank" rel="noopener">参考：快手万亿级别 Kafka 集群应用实践与技术演进之路</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统基础知识</title>
      <link href="/2019/06/16/tui-jian-xi-tong-ji-chu-zhi-shi/"/>
      <url>/2019/06/16/tui-jian-xi-tong-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>推荐系统是现在消费互联网为了吸引点击率常用的手段，本文就推荐系统常用的知识做一些总结</p><h2 id="计算物品距离的几种方法"><a href="#计算物品距离的几种方法" class="headerlink" title="计算物品距离的几种方法"></a>计算物品距离的几种方法</h2><h3 id="欧几里得距离-Euclidean-Distance"><a href="#欧几里得距离-Euclidean-Distance" class="headerlink" title="欧几里得距离(Euclidean Distance)"></a>欧几里得距离(Euclidean Distance)</h3><p>最常见的距离度量方式，衡量多维空间中两点之间的绝对距离，要求维度的统一。</p><p>$$<br>dist(X,Y)=\sqrt{\sum_{i=1}^n(x_i-y_i)^2}<br>$$</p><h3 id="明可夫斯基距离-Minkowski-Distance"><a href="#明可夫斯基距离-Minkowski-Distance" class="headerlink" title="明可夫斯基距离(Minkowski Distance)"></a>明可夫斯基距离(Minkowski Distance)</h3><p>明氏距离是欧氏距离的扩展，是对多个距离度量公式的概括性的表述(可以看到，当p=2时，其实就是欧式距离)。</p><p>$$<br>dist(X,Y)=(\sum_{i=1}^n|x_i-y_i|^p)^{1/p}<br>$$<br>    或<br>$$<br>dist(X,Y)=\sqrt[p]{(\sum_{i=1}^n|x_i-y_i|^p)}<br>$$</p><h3 id="曼哈顿距离-Manhattan-Distance"><a href="#曼哈顿距离-Manhattan-Distance" class="headerlink" title="曼哈顿距离(Manhattan Distance)"></a>曼哈顿距离(Manhattan Distance)</h3><p>曼哈顿距离来源于城市区块距离，是将多个维度上的距离进行求和后的结果，即当上面的明氏距离中p=1时得到的距离度量。<br>$$<br>dist(X,Y)=\sum_{i=1}^n|x_i-y_i|<br>$$<br>//还有其他的一些距离度量，但是都不太常用，最常用的依然是欧式距离度量。</p><h3 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h3><p>切比雪夫距离（Chebyshev distance）或是L∞度量，是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值</p><h2 id="计算相似度量的几种方法"><a href="#计算相似度量的几种方法" class="headerlink" title="计算相似度量的几种方法"></a>计算相似度量的几种方法</h2><h3 id="向量空间余弦相似度-Cosine-Similarity"><a href="#向量空间余弦相似度-Cosine-Similarity" class="headerlink" title="向量空间余弦相似度(Cosine Similarity)"></a>向量空间余弦相似度(Cosine Similarity)</h3><p>余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度上。</p><p>$$<br>sim(X,Y) = \cos\theta = \frac {\vec{x} \cdot \vec{y}} {||x|| \cdot ||y||}<br>$$</p><h3 id="皮尔森相关系数-Pearson-Correlation-Coefficient"><a href="#皮尔森相关系数-Pearson-Correlation-Coefficient" class="headerlink" title="皮尔森相关系数(Pearson Correlation Coefficient)"></a>皮尔森相关系数(Pearson Correlation Coefficient)</h3><p>即相关分析中的相关系数r，分别对X和Y基于自身总体标准化后计算空间向量的余弦夹角。<br><img src="/medias/myimages/%E7%9A%AE%E5%B0%94%E6%A3%AE%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0.png" alt="皮尔森相关系数"></p><h2 id="关于用户评分的说明"><a href="#关于用户评分的说明" class="headerlink" title="关于用户评分的说明"></a>关于用户评分的说明</h2><p>有些系统没有用户评分机制，所以可以用用户对物品的行为+行为权重(喜爱程度权重)综合衡量作为用户对物品的评分</p><h2 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h2><ul><li>step1、将ItermProfile转置(物品的特征(标签)的特征矩阵)</li><li>step2、将ItermUser(评分矩阵)乘以ItermProfile(转置)</li><li>step3、计算用户与物品的向量(的余弦)相似度,得到推荐列表(用户对某物品的喜爱程度)</li><li>step4、将用户已经有过行为的的物品的相似度置0</li></ul><h3 id="基于用户的协同-UserCF"><a href="#基于用户的协同-UserCF" class="headerlink" title="基于用户的协同(UserCF)"></a>基于用户的协同(UserCF)</h3><ul><li>step1、根据用户行为列表构建评分矩阵</li><li>step2、利用评分矩阵计算用户与用户的相似度矩阵</li><li>step3、将评分矩阵转置</li><li>step4、用户与用户相似度矩阵乘以评分矩阵=推荐列表</li><li>step5、推荐列表中用户之前已经有过行为的的商品评分置0</li></ul><h3 id="基于物品的协同-ItemCF"><a href="#基于物品的协同-ItemCF" class="headerlink" title="基于物品的协同(ItemCF)"></a>基于物品的协同(ItemCF)</h3><ul><li>step1、根据用户的行为计算用户、物品的评分矩阵</li><li>step2、根据用户、物品的评分矩阵计算物品、物品的相似矩阵</li><li>step3、根据物品与物品的相似矩阵乘以用户、物品的评分矩阵=推荐列表</li><li>step4、推荐列表中用户之前已经有过行为的元素值0</li></ul><h3 id="基于模型的协同-ModelCF"><a href="#基于模型的协同-ModelCF" class="headerlink" title="基于模型的协同(ModelCF)"></a>基于模型的协同(ModelCF)</h3><p>常见的基于模型推荐又有三种：最近邻模型，典型如K最近邻；SVD模型，即矩阵分解；图模型，又称为社会网络图模型。</p><h4 id="最近邻模型"><a href="#最近邻模型" class="headerlink" title="最近邻模型"></a>最近邻模型</h4><h4 id="SVD矩阵分解"><a href="#SVD矩阵分解" class="headerlink" title="SVD矩阵分解"></a>SVD矩阵分解</h4><h4 id="社会网络图模型"><a href="#社会网络图模型" class="headerlink" title="社会网络图模型"></a>社会网络图模型</h4><h3 id="其他相关知识"><a href="#其他相关知识" class="headerlink" title="其他相关知识"></a>其他相关知识</h3><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><h4 id="长尾效应-马太效应"><a href="#长尾效应-马太效应" class="headerlink" title="长尾效应/马太效应"></a>长尾效应/马太效应</h4><pre><code>- 长尾效应： 强调“个性化”，“客户力量”和“小利润大市场”，也就是要赚很少的钱，但是要赚很多人的钱- 马太效应： 强者更强，弱者更弱</code></pre><h4 id="AB分流测试"><a href="#AB分流测试" class="headerlink" title="AB分流测试"></a>AB分流测试</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.blogchong.com/post/129.html" target="_blank" rel="noopener">推荐系统相关知识http://www.blogchong.com/post/129.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentantLock</title>
      <link href="/2019/06/15/reentrantlock-jie-xi/"/>
      <url>/2019/06/15/reentrantlock-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>针对Java中高并发场景下最常用的数据结构ReentantLock解析</p><h2 id="ReentrantLock继承体系"><a href="#ReentrantLock继承体系" class="headerlink" title="ReentrantLock继承体系"></a>ReentrantLock继承体系</h2><p><img src="/medias/myimages/ReentrantLock%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="ReentrantLock继承体系"></p><h2 id="非公平锁加锁过程"><a href="#非公平锁加锁过程" class="headerlink" title="非公平锁加锁过程"></a>非公平锁加锁过程</h2><p><img src="/medias/myimages/NonfairLock%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B.png" alt="NonfairLock加锁过程"></p>]]></content>
      
      
      <categories>
          
          <category> 探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/04/hello-world/"/>
      <url>/2019/06/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><pre><code>#include&lt;stdout.h&gt;_int main(){    printf(&quot;%s&quot;,&quot;helloWorld&quot;);}</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 随写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
